import { LRUCache, TTLCache, MemoryPool, BufferPool, StringPool } from '../src/performance';\n\ndescribe('LRUCache', () => {\n  let cache: LRUCache<string, number>;\n\n  beforeEach(() => {\n    cache = new LRUCache(3);\n  });\n\n  test('should store and retrieve values', () => {\n    cache.set('a', 1);\n    cache.set('b', 2);\n    \n    expect(cache.get('a')).toBe(1);\n    expect(cache.get('b')).toBe(2);\n    expect(cache.size()).toBe(2);\n  });\n\n  test('should evict least recently used items when capacity exceeded', () => {\n    cache.set('a', 1);\n    cache.set('b', 2);\n    cache.set('c', 3);\n    cache.set('d', 4); // Should evict 'a'\n    \n    expect(cache.get('a')).toBeUndefined();\n    expect(cache.get('b')).toBe(2);\n    expect(cache.get('c')).toBe(3);\n    expect(cache.get('d')).toBe(4);\n  });\n\n  test('should update access order on get', () => {\n    cache.set('a', 1);\n    cache.set('b', 2);\n    cache.set('c', 3);\n    \n    // Access 'a' to make it most recently used\n    cache.get('a');\n    \n    cache.set('d', 4); // Should evict 'b' instead of 'a'\n    \n    expect(cache.get('a')).toBe(1);\n    expect(cache.get('b')).toBeUndefined();\n    expect(cache.get('c')).toBe(3);\n    expect(cache.get('d')).toBe(4);\n  });\n\n  test('should update existing keys without changing capacity', () => {\n    cache.set('a', 1);\n    cache.set('b', 2);\n    cache.set('c', 3);\n    \n    cache.set('a', 10); // Update existing key\n    \n    expect(cache.size()).toBe(3);\n    expect(cache.get('a')).toBe(10);\n  });\n\n  test('should provide accurate statistics', () => {\n    cache.set('a', 1);\n    cache.set('b', 2);\n    \n    const stats = cache.getStats();\n    expect(stats.size).toBe(2);\n    expect(stats.capacity).toBe(3);\n    expect(stats.oldestKey).toBe('a');\n    expect(stats.newestKey).toBe('b');\n  });\n});\n\ndescribe('TTLCache', () => {\n  let cache: TTLCache<string, number>;\n\n  beforeEach(() => {\n    cache = new TTLCache(3, 100); // 100ms TTL\n  });\n\n  afterEach(() => {\n    cache.destroy();\n  });\n\n  test('should expire items after TTL', async () => {\n    cache.set('a', 1);\n    expect(cache.get('a')).toBe(1);\n    \n    // Wait for TTL to expire\n    await new Promise(resolve => setTimeout(resolve, 150));\n    \n    expect(cache.get('a')).toBeUndefined();\n  });\n\n  test('should not return expired items', () => {\n    cache.set('a', 1);\n    \n    // Manually set expiration time in the past\n    (cache as any).ttlMap.set('a', Date.now() - 1000);\n    \n    expect(cache.get('a')).toBeUndefined();\n  });\n\n  test('should clean up expired items periodically', async () => {\n    const shortTTLCache = new TTLCache<string, number>(10, 50, 60); // 60ms cleanup interval\n    \n    shortTTLCache.set('a', 1);\n    shortTTLCache.set('b', 2);\n    \n    // Wait for items to expire and cleanup to run\n    await new Promise(resolve => setTimeout(resolve, 120));\n    \n    expect(shortTTLCache.size()).toBe(0);\n    \n    shortTTLCache.destroy();\n  });\n});\n\ndescribe('MemoryPool', () => {\n  test('should reuse objects from the pool', () => {\n    const factory = jest.fn(() => ({ value: 0 }));\n    const reset = jest.fn((obj: any) => { obj.value = 0; });\n    const pool = new MemoryPool(factory, 5, reset);\n    \n    // Acquire and release an object\n    const obj1 = pool.acquire();\n    obj1.value = 42;\n    pool.release(obj1);\n    \n    // Acquire another object - should reuse the first one\n    const obj2 = pool.acquire();\n    \n    expect(obj1).toBe(obj2); // Same object reference\n    expect(reset).toHaveBeenCalledWith(obj1);\n    expect(obj2.value).toBe(0); // Reset was called\n    expect(factory).toHaveBeenCalledTimes(1); // Only created once\n  });\n\n  test('should create new objects when pool is empty', () => {\n    const factory = jest.fn(() => ({ id: Math.random() }));\n    const pool = new MemoryPool(factory, 5);\n    \n    const obj1 = pool.acquire();\n    const obj2 = pool.acquire();\n    \n    expect(obj1).not.toBe(obj2);\n    expect(factory).toHaveBeenCalledTimes(2);\n  });\n\n  test('should respect maximum pool size', () => {\n    const factory = () => ({ value: 0 });\n    const pool = new MemoryPool(factory, 2);\n    \n    // Fill the pool beyond capacity\n    const obj1 = pool.acquire();\n    const obj2 = pool.acquire();\n    const obj3 = pool.acquire();\n    \n    pool.release(obj1);\n    pool.release(obj2);\n    pool.release(obj3); // This should not be stored due to capacity limit\n    \n    const stats = pool.getStats();\n    expect(stats.available).toBe(2); // Only 2 objects stored\n    expect(stats.inUse).toBe(0);\n  });\n\n  test('should pre-fill the pool', () => {\n    const factory = jest.fn(() => ({ value: 0 }));\n    const pool = new MemoryPool(factory, 10);\n    \n    pool.preFill(5);\n    \n    const stats = pool.getStats();\n    expect(stats.available).toBe(5);\n    expect(factory).toHaveBeenCalledTimes(5);\n  });\n});\n\ndescribe('BufferPool', () => {\n  let pool: BufferPool;\n\n  beforeEach(() => {\n    pool = new BufferPool();\n  });\n\n  afterEach(() => {\n    pool.clear();\n  });\n\n  test('should provide buffers of requested size', () => {\n    const buffer = pool.acquire(1024);\n    \n    expect(Buffer.isBuffer(buffer)).toBe(true);\n    expect(buffer.length).toBe(1024);\n  });\n\n  test('should reuse buffers for common sizes', () => {\n    const buffer1 = pool.acquire(4096);\n    pool.release(buffer1);\n    \n    const buffer2 = pool.acquire(4096);\n    \n    // Should be the same underlying buffer (though sliced)\n    expect(buffer1.buffer).toBe(buffer2.buffer);\n  });\n\n  test('should handle uncommon buffer sizes', () => {\n    const buffer = pool.acquire(3333); // Uncommon size\n    \n    expect(Buffer.isBuffer(buffer)).toBe(true);\n    expect(buffer.length).toBe(3333);\n    \n    // Should not error when releasing\n    expect(() => pool.release(buffer)).not.toThrow();\n  });\n\n  test('should provide buffer statistics', () => {\n    pool.acquire(1024);\n    pool.acquire(4096);\n    \n    const stats = pool.getStats();\n    \n    expect(typeof stats).toBe('object');\n    expect(stats[1024]).toBeDefined();\n    expect(stats[4096]).toBeDefined();\n  });\n});\n\ndescribe('StringPool', () => {\n  let pool: StringPool;\n\n  beforeEach(() => {\n    pool = new StringPool();\n  });\n\n  afterEach(() => {\n    pool.clear();\n  });\n\n  test('should intern duplicate strings', () => {\n    const str1 = pool.intern('hello');\n    const str2 = pool.intern('hello');\n    \n    expect(str1).toBe(str2); // Same reference\n    expect(pool.size()).toBe(1);\n  });\n\n  test('should handle different strings', () => {\n    const str1 = pool.intern('hello');\n    const str2 = pool.intern('world');\n    \n    expect(str1).not.toBe(str2);\n    expect(str1).toBe('hello');\n    expect(str2).toBe('world');\n    expect(pool.size()).toBe(2);\n  });\n\n  test('should clean up garbage collected references', () => {\n    // This test is tricky because we can't force garbage collection\n    // But we can test that the cleanup method doesn't throw\n    pool.intern('test1');\n    pool.intern('test2');\n    \n    // Call cleanup manually (normally called automatically)\n    (pool as any).cleanup();\n    \n    expect(pool.size()).toBeGreaterThanOrEqual(0);\n  });\n});