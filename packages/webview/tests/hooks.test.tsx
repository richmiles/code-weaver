import { renderHook, act } from '@testing-library/react';\nimport { useAsyncState } from '../src/hooks/useAsyncState';\nimport { useKeyboardShortcuts } from '../src/hooks/useKeyboardShortcuts';\n\ndescribe('useAsyncState', () => {\n  test('should initialize with default values', () => {\n    const { result } = renderHook(() => useAsyncState<string>());\n    \n    expect(result.current.data).toBeNull();\n    expect(result.current.loading).toBe(false);\n    expect(result.current.error).toBeNull();\n  });\n\n  test('should initialize with provided initial data', () => {\n    const { result } = renderHook(() => useAsyncState<string>('initial'));\n    \n    expect(result.current.data).toBe('initial');\n  });\n\n  test('should handle successful async operation', async () => {\n    const { result } = renderHook(() => useAsyncState<string>());\n    \n    const asyncFn = jest.fn().mockResolvedValue('success');\n    \n    await act(async () => {\n      await result.current.execute(asyncFn);\n    });\n    \n    expect(result.current.data).toBe('success');\n    expect(result.current.loading).toBe(false);\n    expect(result.current.error).toBeNull();\n    expect(asyncFn).toHaveBeenCalledTimes(1);\n  });\n\n  test('should handle failed async operation', async () => {\n    const { result } = renderHook(() => useAsyncState<string>());\n    \n    const error = new Error('Test error');\n    const asyncFn = jest.fn().mockRejectedValue(error);\n    \n    await act(async () => {\n      try {\n        await result.current.execute(asyncFn);\n      } catch (e) {\n        // Expected to throw\n      }\n    });\n    \n    expect(result.current.data).toBeNull();\n    expect(result.current.loading).toBe(false);\n    expect(result.current.error).toBe(error);\n  });\n\n  test('should set loading state during execution', async () => {\n    const { result } = renderHook(() => useAsyncState<string>());\n    \n    const asyncFn = jest.fn(() => new Promise(resolve => setTimeout(() => resolve('done'), 100)));\n    \n    act(() => {\n      result.current.execute(asyncFn);\n    });\n    \n    expect(result.current.loading).toBe(true);\n    \n    await act(async () => {\n      await new Promise(resolve => setTimeout(resolve, 150));\n    });\n    \n    expect(result.current.loading).toBe(false);\n    expect(result.current.data).toBe('done');\n  });\n\n  test('should reset state', () => {\n    const { result } = renderHook(() => useAsyncState<string>('initial'));\n    \n    act(() => {\n      result.current.setData('changed');\n      result.current.setError(new Error('test'));\n    });\n    \n    act(() => {\n      result.current.reset();\n    });\n    \n    expect(result.current.data).toBe('initial');\n    expect(result.current.loading).toBe(false);\n    expect(result.current.error).toBeNull();\n  });\n\n  test('should manually set data and error', () => {\n    const { result } = renderHook(() => useAsyncState<string>());\n    \n    const error = new Error('Manual error');\n    \n    act(() => {\n      result.current.setData('manual data');\n    });\n    \n    expect(result.current.data).toBe('manual data');\n    \n    act(() => {\n      result.current.setError(error);\n    });\n    \n    expect(result.current.error).toBe(error);\n    expect(result.current.loading).toBe(false);\n  });\n});\n\ndescribe('useKeyboardShortcuts', () => {\n  let mockAddEventListener: jest.SpyInstance;\n  let mockRemoveEventListener: jest.SpyInstance;\n  let eventListeners: { [key: string]: ((event: any) => void)[] } = {};\n\n  beforeEach(() => {\n    eventListeners = {};\n    \n    mockAddEventListener = jest.spyOn(window, 'addEventListener').mockImplementation((type, listener) => {\n      if (!eventListeners[type]) {\n        eventListeners[type] = [];\n      }\n      eventListeners[type].push(listener as any);\n    });\n    \n    mockRemoveEventListener = jest.spyOn(window, 'removeEventListener').mockImplementation((type, listener) => {\n      if (eventListeners[type]) {\n        const index = eventListeners[type].indexOf(listener as any);\n        if (index > -1) {\n          eventListeners[type].splice(index, 1);\n        }\n      }\n    });\n  });\n\n  afterEach(() => {\n    mockAddEventListener.mockRestore();\n    mockRemoveEventListener.mockRestore();\n  });\n\n  const simulateKeyDown = (key: string, modifiers: any = {}) => {\n    const event = {\n      key,\n      ctrlKey: modifiers.ctrl || false,\n      altKey: modifiers.alt || false,\n      shiftKey: modifiers.shift || false,\n      metaKey: modifiers.meta || false,\n      preventDefault: jest.fn()\n    };\n    \n    eventListeners['keydown']?.forEach(listener => listener(event));\n    return event;\n  };\n\n  test('should register keyboard shortcuts', () => {\n    const action = jest.fn();\n    const shortcuts = [{\n      key: 'f',\n      ctrl: true,\n      action,\n      description: 'Test shortcut'\n    }];\n    \n    renderHook(() => useKeyboardShortcuts(shortcuts));\n    \n    expect(mockAddEventListener).toHaveBeenCalledWith('keydown', expect.any(Function));\n  });\n\n  test('should trigger action on matching shortcut', () => {\n    const action = jest.fn();\n    const shortcuts = [{\n      key: 'f',\n      ctrl: true,\n      action,\n      description: 'Test shortcut'\n    }];\n    \n    renderHook(() => useKeyboardShortcuts(shortcuts));\n    \n    const event = simulateKeyDown('f', { ctrl: true });\n    \n    expect(action).toHaveBeenCalledTimes(1);\n    expect(event.preventDefault).toHaveBeenCalled();\n  });\n\n  test('should not trigger action on non-matching shortcut', () => {\n    const action = jest.fn();\n    const shortcuts = [{\n      key: 'f',\n      ctrl: true,\n      action,\n      description: 'Test shortcut'\n    }];\n    \n    renderHook(() => useKeyboardShortcuts(shortcuts));\n    \n    simulateKeyDown('f', { alt: true }); // Wrong modifier\n    simulateKeyDown('g', { ctrl: true }); // Wrong key\n    \n    expect(action).not.toHaveBeenCalled();\n  });\n\n  test('should handle multiple shortcuts', () => {\n    const action1 = jest.fn();\n    const action2 = jest.fn();\n    const shortcuts = [\n      { key: 'f', ctrl: true, action: action1, description: 'Shortcut 1' },\n      { key: 'g', alt: true, action: action2, description: 'Shortcut 2' }\n    ];\n    \n    renderHook(() => useKeyboardShortcuts(shortcuts));\n    \n    simulateKeyDown('f', { ctrl: true });\n    simulateKeyDown('g', { alt: true });\n    \n    expect(action1).toHaveBeenCalledTimes(1);\n    expect(action2).toHaveBeenCalledTimes(1);\n  });\n\n  test('should handle shortcuts with multiple modifiers', () => {\n    const action = jest.fn();\n    const shortcuts = [{\n      key: 's',\n      ctrl: true,\n      shift: true,\n      action,\n      description: 'Save as'\n    }];\n    \n    renderHook(() => useKeyboardShortcuts(shortcuts));\n    \n    simulateKeyDown('s', { ctrl: true, shift: true });\n    \n    expect(action).toHaveBeenCalledTimes(1);\n  });\n\n  test('should not prevent default when specified', () => {\n    const action = jest.fn();\n    const shortcuts = [{\n      key: 'f',\n      action,\n      description: 'Test shortcut',\n      preventDefault: false\n    }];\n    \n    renderHook(() => useKeyboardShortcuts(shortcuts));\n    \n    const event = simulateKeyDown('f');\n    \n    expect(action).toHaveBeenCalledTimes(1);\n    expect(event.preventDefault).not.toHaveBeenCalled();\n  });\n\n  test('should case-insensitive key matching', () => {\n    const action = jest.fn();\n    const shortcuts = [{\n      key: 'F', // Uppercase\n      action,\n      description: 'Test shortcut'\n    }];\n    \n    renderHook(() => useKeyboardShortcuts(shortcuts));\n    \n    simulateKeyDown('f'); // Lowercase\n    \n    expect(action).toHaveBeenCalledTimes(1);\n  });\n\n  test('should cleanup event listeners on unmount', () => {\n    const shortcuts = [{\n      key: 'f',\n      action: jest.fn(),\n      description: 'Test shortcut'\n    }];\n    \n    const { unmount } = renderHook(() => useKeyboardShortcuts(shortcuts));\n    \n    unmount();\n    \n    expect(mockRemoveEventListener).toHaveBeenCalledWith('keydown', expect.any(Function));\n  });\n\n  test('should update shortcuts when dependencies change', () => {\n    const action1 = jest.fn();\n    const action2 = jest.fn();\n    \n    let shortcuts = [{ key: 'f', action: action1, description: 'First' }];\n    \n    const { rerender } = renderHook(() => useKeyboardShortcuts(shortcuts));\n    \n    simulateKeyDown('f');\n    expect(action1).toHaveBeenCalledTimes(1);\n    \n    // Update shortcuts\n    shortcuts = [{ key: 'f', action: action2, description: 'Second' }];\n    rerender();\n    \n    simulateKeyDown('f');\n    expect(action2).toHaveBeenCalledTimes(1);\n    expect(action1).toHaveBeenCalledTimes(1); // Should not be called again\n  });\n});