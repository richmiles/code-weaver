import { WebSocketClient } from '../src/websocketClient';\nimport { MessageType } from '@codeweaver/core';\nimport WebSocket from 'ws';\n\n// Mock WebSocket for testing\nclass MockWebSocket {\n  static CONNECTING = 0;\n  static OPEN = 1;\n  static CLOSING = 2;\n  static CLOSED = 3;\n\n  readyState = MockWebSocket.CONNECTING;\n  onopen: ((event: any) => void) | null = null;\n  onclose: ((event: any) => void) | null = null;\n  onerror: ((event: any) => void) | null = null;\n  onmessage: ((event: any) => void) | null = null;\n\n  private messageQueue: string[] = [];\n\n  constructor(public url: string) {\n    // Simulate async connection\n    setTimeout(() => {\n      this.readyState = MockWebSocket.OPEN;\n      this.onopen?.({});\n    }, 10);\n  }\n\n  send(data: string) {\n    if (this.readyState !== MockWebSocket.OPEN) {\n      throw new Error('WebSocket is not open');\n    }\n    this.messageQueue.push(data);\n  }\n\n  close(code?: number, reason?: string) {\n    this.readyState = MockWebSocket.CLOSED;\n    this.onclose?.({ code: code || 1000, reason: reason || '' });\n  }\n\n  // Test helper methods\n  simulateMessage(message: any) {\n    this.onmessage?.({ data: JSON.stringify(message) });\n  }\n\n  simulateError(error: Error) {\n    this.onerror?.(error);\n  }\n\n  simulateClose(code = 1000, reason = '') {\n    this.readyState = MockWebSocket.CLOSED;\n    this.onclose?.({ code, reason });\n  }\n\n  getLastMessage() {\n    return this.messageQueue[this.messageQueue.length - 1];\n  }\n\n  getAllMessages() {\n    return [...this.messageQueue];\n  }\n\n  clearMessages() {\n    this.messageQueue = [];\n  }\n}\n\n// Replace global WebSocket with mock\n(global as any).WebSocket = MockWebSocket;\n\ndescribe('WebSocketClient Integration Tests', () => {\n  let client: WebSocketClient;\n  let mockWebSocket: MockWebSocket;\n  let eventCallbacks: {\n    onConnect?: jest.Mock;\n    onDisconnect?: jest.Mock;\n    onError?: jest.Mock;\n    onMessage?: jest.Mock;\n    onReconnecting?: jest.Mock;\n    onReconnected?: jest.Mock;\n  };\n\n  beforeEach(() => {\n    eventCallbacks = {\n      onConnect: jest.fn(),\n      onDisconnect: jest.fn(),\n      onError: jest.fn(),\n      onMessage: jest.fn(),\n      onReconnecting: jest.fn(),\n      onReconnected: jest.fn()\n    };\n\n    client = new WebSocketClient('ws://localhost:8080', {\n      events: eventCallbacks,\n      reconnectInterval: 100,\n      maxReconnectAttempts: 3,\n      heartbeatInterval: 1000\n    });\n  });\n\n  afterEach(async () => {\n    if (client.isActive()) {\n      client.disconnect();\n    }\n    await new Promise(resolve => setTimeout(resolve, 50));\n  });\n\n  describe('Connection Management', () => {\n    test('should connect successfully', async () => {\n      await client.connect();\n      \n      expect(client.isActive()).toBe(true);\n      expect(client.getConnectionState()).toBe('connected');\n      expect(eventCallbacks.onConnect).toHaveBeenCalledTimes(1);\n    });\n\n    test('should handle connection timeout', async () => {\n      // Mock WebSocket that never opens\n      (global as any).WebSocket = class extends MockWebSocket {\n        constructor(url: string) {\n          super(url);\n          // Don't auto-open\n        }\n      };\n\n      await expect(client.connect({ timeout: 100 })).rejects.toThrow('Connection timeout');\n    });\n\n    test('should disconnect cleanly', async () => {\n      await client.connect();\n      client.disconnect();\n      \n      expect(client.isActive()).toBe(false);\n      expect(client.getConnectionState()).toBe('disconnected');\n      expect(eventCallbacks.onDisconnect).toHaveBeenCalledWith(1000, 'Client disconnect');\n    });\n\n    test('should provide connection health metrics', async () => {\n      await client.connect();\n      \n      const health = client.getConnectionHealth();\n      expect(health.isConnected).toBe(true);\n      expect(health.reconnectAttempts).toBe(0);\n      expect(health.pendingRequests).toBe(0);\n      expect(health.queuedMessages).toBe(0);\n    });\n  });\n\n  describe('Message Handling', () => {\n    beforeEach(async () => {\n      await client.connect();\n      mockWebSocket = (client as any).socket;\n    });\n\n    test('should send messages when connected', () => {\n      const message = {\n        type: MessageType.GET_SOURCES,\n        id: 'test-123',\n        timestamp: new Date()\n      };\n\n      client.send(message);\n      \n      const sentMessage = JSON.parse(mockWebSocket.getLastMessage());\n      expect(sentMessage.type).toBe(MessageType.GET_SOURCES);\n      expect(sentMessage.id).toBe('test-123');\n    });\n\n    test('should queue messages when disconnected with auto-reconnect', () => {\n      client.disconnect();\n      \n      const message = {\n        type: MessageType.GET_SOURCES,\n        id: 'test-123',\n        timestamp: new Date()\n      };\n\n      // Should not throw when auto-reconnect is enabled\n      expect(() => client.send(message)).not.toThrow();\n      \n      const health = client.getConnectionHealth();\n      expect(health.queuedMessages).toBe(1);\n    });\n\n    test('should handle sendAndWait with response', async () => {\n      const message = {\n        type: MessageType.GET_SOURCES,\n        id: 'test-123',\n        timestamp: new Date()\n      };\n\n      // Send message and simulate response\n      const responsePromise = client.sendAndWait(message);\n      \n      // Simulate server response\n      setTimeout(() => {\n        mockWebSocket.simulateMessage({\n          requestId: 'test-123',\n          success: true,\n          data: ['source1', 'source2'],\n          timestamp: new Date()\n        });\n      }, 10);\n\n      const response = await responsePromise;\n      expect(response.success).toBe(true);\n      expect(response.data).toEqual(['source1', 'source2']);\n    });\n\n    test('should timeout on sendAndWait', async () => {\n      const message = {\n        type: MessageType.GET_SOURCES,\n        id: 'test-123',\n        timestamp: new Date()\n      };\n\n      await expect(client.sendAndWait(message, 100)).rejects.toThrow('Request timeout');\n    });\n\n    test('should handle event messages', () => {\n      const eventMessage = {\n        type: MessageType.EVENT,\n        payload: {\n          type: 'source_added',\n          data: { sourceId: 'new-source' }\n        }\n      };\n\n      mockWebSocket.simulateMessage(eventMessage);\n      \n      expect(eventCallbacks.onMessage).toHaveBeenCalledWith(eventMessage);\n    });\n  });\n\n  describe('Reconnection Logic', () => {\n    test('should attempt reconnection on unexpected disconnect', async () => {\n      await client.connect();\n      mockWebSocket = (client as any).socket;\n      \n      // Simulate unexpected disconnect\n      mockWebSocket.simulateClose(1006, 'Connection lost');\n      \n      await new Promise(resolve => setTimeout(resolve, 150));\n      \n      expect(eventCallbacks.onReconnecting).toHaveBeenCalled();\n      expect(client.getConnectionState()).toBe('reconnecting');\n    });\n\n    test('should not reconnect on normal close', async () => {\n      await client.connect();\n      mockWebSocket = (client as any).socket;\n      \n      // Simulate normal close\n      mockWebSocket.simulateClose(1000, 'Normal close');\n      \n      await new Promise(resolve => setTimeout(resolve, 150));\n      \n      expect(eventCallbacks.onReconnecting).not.toHaveBeenCalled();\n      expect(client.getConnectionState()).toBe('disconnected');\n    });\n\n    test('should respect max reconnection attempts', async () => {\n      const clientWithLimitedRetries = new WebSocketClient('ws://localhost:8080', {\n        events: eventCallbacks,\n        reconnectInterval: 50,\n        maxReconnectAttempts: 2\n      });\n\n      // Mock WebSocket that always fails to connect\n      (global as any).WebSocket = class extends MockWebSocket {\n        constructor(url: string) {\n          super(url);\n          setTimeout(() => {\n            this.simulateClose(1006, 'Connection failed');\n          }, 10);\n        }\n      };\n\n      try {\n        await clientWithLimitedRetries.connect();\n      } catch (error) {\n        // Expected to fail\n      }\n\n      // Wait for all reconnection attempts\n      await new Promise(resolve => setTimeout(resolve, 300));\n      \n      // Should have called onReconnecting for each attempt (up to max)\n      expect(eventCallbacks.onReconnecting).toHaveBeenCalledTimes(2);\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('should handle malformed messages gracefully', async () => {\n      await client.connect();\n      mockWebSocket = (client as any).socket;\n      \n      // Simulate malformed JSON\n      mockWebSocket.onmessage?.({ data: 'invalid json' });\n      \n      expect(eventCallbacks.onError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          message: expect.stringContaining('Failed to parse message')\n        })\n      );\n    });\n\n    test('should handle WebSocket errors', async () => {\n      await client.connect();\n      mockWebSocket = (client as any).socket;\n      \n      const testError = new Error('WebSocket error');\n      mockWebSocket.simulateError(testError);\n      \n      expect(eventCallbacks.onError).toHaveBeenCalled();\n    });\n  });\n\n  describe('API Methods', () => {\n    beforeEach(async () => {\n      await client.connect();\n      mockWebSocket = (client as any).socket;\n    });\n\n    test('should call getSources', async () => {\n      const responsePromise = client.getSources();\n      \n      // Simulate response\n      setTimeout(() => {\n        const message = JSON.parse(mockWebSocket.getLastMessage());\n        mockWebSocket.simulateMessage({\n          requestId: message.id,\n          success: true,\n          data: [{ id: '1', type: 'file', name: 'test.ts' }]\n        });\n      }, 10);\n\n      const sources = await responsePromise;\n      expect(sources).toEqual([{ id: '1', type: 'file', name: 'test.ts' }]);\n    });\n\n    test('should call addSource', async () => {\n      const newSource = {\n        type: 'file' as const,\n        name: 'new-file.ts',\n        path: '/path/to/file'\n      };\n      \n      const responsePromise = client.addSource(newSource);\n      \n      setTimeout(() => {\n        const message = JSON.parse(mockWebSocket.getLastMessage());\n        expect(message.type).toBe(MessageType.ADD_SOURCE);\n        expect(message.payload).toEqual(newSource);\n        \n        mockWebSocket.simulateMessage({\n          requestId: message.id,\n          success: true,\n          data: { ...newSource, id: 'new-id' }\n        });\n      }, 10);\n\n      const result = await responsePromise;\n      expect(result.name).toBe('new-file.ts');\n    });\n\n    test('should handle search operations', async () => {\n      const responsePromise = client.searchFiles('test', 10);\n      \n      setTimeout(() => {\n        const message = JSON.parse(mockWebSocket.getLastMessage());\n        expect(message.type).toBe(MessageType.SEARCH_FILES);\n        expect(message.payload.query).toBe('test');\n        expect(message.payload.maxResults).toBe(10);\n        \n        mockWebSocket.simulateMessage({\n          requestId: message.id,\n          success: true,\n          data: {\n            query: 'test',\n            results: [{ path: '/test.ts', name: 'test.ts', isDirectory: false, score: 100 }]\n          }\n        });\n      }, 10);\n\n      const result = await responsePromise;\n      expect(result.results).toHaveLength(1);\n      expect(result.results[0].name).toBe('test.ts');\n    });\n  });\n});